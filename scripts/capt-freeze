#! /usr/bin/env python
#
#  Freeze a package or project to a new version.

import re
import os
import os.path
import pwd
import optparse
import sys
import time
import socket
import textwrap

from captain import git
from captain import cmt

#Define the command line options and parse the command line.
usage = """Usage: %prog [options] 

    Freeze version of a git repository.  This manipulates git branches and
    tags to update the version, and also generates the history files
    needed for the doxygen documentation.  The version numbers
    generated by this script have the form "v.r.p" where "v" is the
    major version, "r" is the release number, and "p" is a patch
    number.  The convention is that versions represent incompatible
    changes; releases represent new features, but are otherwise remain
    compatible; and, patches represent bug fixes.

    Unless the "--apply" option is provided, this will not modify the
    state of the repository (i.e. it defaults to "--dry-run")."""
parser = optparse.OptionParser(usage=usage)
parser.add_option("-d","--dry-run",
                  action="store_true", default=True, dest="dryRun",
                  help="Determine the release versions, but do nothing.")
parser.add_option("--apply",
                  action="store_false",dest="dryRun",
                  help="Apply the changes.")
parser.add_option("--force-version",
                  action="store_true", default=False, dest="forceVersion",
                  help="Force a new major version. Use this is the package has major interface changes.  It must be run on the master branch.  Overrides the creation of a new release.")
parser.add_option("--force-release",
                  action="store_true", default=False, dest="forceRelease",
                  help="Force a new release version, even if currently on an existing release branch.  Overrides the creation of a new patch.")
parser.add_option("--force-patch",
                  action="store_true", default=False, dest="forcePatch",
                  help="Force a new release version, even if currently on an existing release branch.  Overrides the creation of a new patch.")
parser.add_option("--trace",
                  action="store_true", default=True, dest="trace",
                  help="Print commands before executing them.")
parser.add_option("--no-trace",
                  action="store_false", dest="trace", 
                  help="Don't print commands before executing them.")
parser.add_option("--name-tag",
                  action="store", dest="nameTag", type="string",
                  help="Set and additional named tag for a stable release of the captainRelease package.  An example might be 'Prod5c'")
parser.add_option("--history",
                  action="store", dest="versionHistory", type="string",
                  default=None,
                  help="Specify version history file. Defaults to None.")
parser.add_option("--skip-history-check",
                  action="store_false", default=True, dest="checkHistory",
                  help="Disable verification checks on the history message. Sometimes for minor freezes these cannot be met and this switch can be used to avoid using filler. This does NOT absolve you from using a complete release history in a freeze!")
parser.add_option("--skip-remote-check",
                  action="store_true", default=False, dest="skipRemoteCheck",
                  help="Skip checking the exists of a remote origin. This allows freezing to proceed even if there isn't a remote repository.  Proceed with extreme caution.")
parser.add_option("--skip-ahead-check",
                  action="store_true", default=False, dest="skipAheadCheck",
                  help="Skip the repository status check. This allows freezing to proceed even if the local repository is not at a branch HEAD, or not synchronized with the remote repository.  Proceed with extreme caution.")
parser.add_option("--skip-modified-check",
                  action="store_true", default=False, dest="skipModifiedCheck",
                  help="Skip checking that all modified files are committed to the local repository.  Proceed with extreme caution.")
parser.add_option("--skip-untracked-check",
                  action="store_true", default=False, dest="skipUntrackedCheck",
                  help="Skip checking that none of the local files are untracked.  Proceed with extreme caution.")

(options,args) = parser.parse_args()

##############################################################
# Collect configuration information about this package.
class Configuration():
    toplevel = None    # The top level directory
    name = None        # The name of what is being frozen
    useCMT = False     # If CMT is available
    cmtProject = False # Is this a CMT project
    cmtPackage = False # Is this a CMT package

    def __init__(self):
        self.toplevel = os.path.relpath(git.GetRepositoryRoot())
        self.useCMT = cmt.CheckCMT()
        if self.useCMT and os.path.exists(self.toplevel+"/cmt"):
            package = cmt.GetPackage(self.toplevel + "/cmt")
            if package != None: 
                self.cmtPackage = True
                self.name = package.name
            else:
                project = cmt.GetProject(self.toplevel +"/cmt")
                if project != None:
                    self.cmtProject = True
                    self.name = project.name
        else:
            self.name = os.path.basename(toplevel)

# This is a global
config = Configuration()

############################################################
def Command(command):
    """Run a system command after apply the effect of command line options

    This responds to the --dry-run and --apply options.
    """
    global options, config

    if options.trace or options.dryRun: print "  >>>", command
    if not options.dryRun: os.system(command)


############################################################
def UnpackVersion(versionString):
    """Unpack the version string

    This has the regular expressions needed to turn the text version
    string into a sequence of integers three.  A missing version value
    will be set to zero.  If the version string is entirely
    incompatible with a version number, (e.g. "master"), this returns
    None.
    """
    match=re.match(r"[^0-9]*([0-9]+)",versionString)
    if match == None: return None
    major = int(match.group(1))
    match=re.match(r"[^0-9]*[0-9]+[^0-9]+([0-9]+)",versionString)
    if match == None: return (major, 0, 0)
    minor = int(match.group(1))
    match=re.match(r"[^0-9]*[0-9]+[^0-9]+[0-9]+[^0-9]+([0-9]+)",
                   versionString)
    if match == None: return (major, minor, 0)
    patch = int(match.group(1))
    return (major, minor, patch)


#############################################################
def KnownVersions():
    """Get a list of all known versions used in this package (or
    project).  The returned list is sorted from lowest to highest."""  
    tags = git.GetTags()
    versions = []
    for t in tags:
        v = UnpackVersion(t)
        if v == None: continue
        versions.append(v)
    versions.sort()
    return versions


############################################################
def CheckReleaseBranch(branchName):
    """ This will be true if the current branch is a release branch."""
    match=re.match(r"[^0-9]*[0-9]+[^0-9]*[0-9]+[^0-9.]*\.x$",
                       branchName)
    if match == None: return False
    return True


############################################################
# Format the version number as a string...
def TextVersion(ver): return "v%dr%dp%d" % ver
def FormatVersion(ver): return "%d.%d.%d" % ver
def FormatBranch(ver): return "%d.%d.x" % (ver[0],ver[1])


############################################################
def GetPreviousVersion():
    """Get the current version from the repository.  

    This is the base that the new version will be constructed from.
    This returns a tuple of (previousVersion, branchVersion,
    releaseBranch, knownVersions) where previousVersion is a 3-tuple
    of (v,r,p), branchVersion is a 3-tuple of (v,r,0) for the release
    branch, releaseBranch is a boolean for if the repository is
    currently on a named release branch (i.e. the name is v.r.x where
    v and r are integers), and knownVersions is a list of 3-tuples of
    all known versions.  Both previousVersion and branchVersion can be
    None"""
    global options, config

    # Find the name of the current branch and see  what version it implies
    branch = git.BranchName()
    releaseBranch = CheckReleaseBranch(branch)
    branchVersion = UnpackVersion(branch);

    # Get the list of all previous versions.
    knownVersions = KnownVersions()

    previousVersion = None
    
    if releaseBranch and len(knownVersions)>0:
        # This is the normal situation on a release branch, and it
        # means we are probably doing a patch release.
        for v in knownVersions:
            if v[0] == branchVersion[0] and v[1] == branchVersion[1]:
                previousVersion = v
        return (previousVersion, branchVersion, releaseBranch, knownVersions)

    if releaseBranch:
        # This is odd.  The repository is on a release branch, but
        # there isn't a version 0 tag.  This happens when people have
        # created the release branch by hand, and have been working on
        # a tagged release candidate.
        return (None, branchVersion, releaseBranch, knownVersions)

    # This means we are not on a release branch, and we are either
    # doing a new release, or a new major version.  The current
    # version will be the highest existing version.  In this case, the
    # branchVersion is likely to be "None"

    if len(knownVersions) < 1:
        # This is the first freeze for the package.  The current
        # version will be "None"
        return (previousVersion, branchVersion, releaseBranch, knownVersions)

    return (knownVersions[-1], branchVersion, releaseBranch, knownVersions)


############################################################
def GetNextVersion():
    """Find the next version for the package.

    This looks at the existing tags and branches, and then finds the
    next tag to be used.  It looks at the options.forcePatch,
    options.forceRelease and options.forceVersion flags to decide how
    the version should be incremented, and will exit if an illegal
    request is made.  It returns a tuple of the next version and
    previous version."""

    global options, config

    (previousVersion, branchVersion, releaseBranch, knownVersions) \
        = GetPreviousVersion()

    case = "invalid"
    if releaseBranch:
        case = "incrementPatch"
        if options.forceRelease: case = "incrementRelease"
        if options.forceVersion: 
            sys.exit("Cannot freeze new version from a release branch")
    else:
        case = "incrementRelease"
        if options.forceVersion: case = "incrementVersion"
        if options.forcePatch:
            sys.exit("Can only freeze patch on from a release branch")
        
    nextVersion = previousVersion
    if nextVersion == None: nextVersion = (0,0,0)
    while nextVersion in knownVersions:
        if case == "incrementPatch": 
            nextVersion = (nextVersion[0], nextVersion[1], nextVersion[2]+1)
        elif case == "incrementRelease": 
            nextVersion = (nextVersion[0], nextVersion[1]+1, 0)
            if releaseBranch and nextVersion in knownVersions: 
                sys.exit("Cannot freeze a new release from this branch")
        elif case == "incrementVersion": nextVersion = (nextVersion[0]+1, 0, 0)
        else: sys.exit("Inconceivable!")

    return (nextVersion, previousVersion)


############################################################
def GetFreezeInformation(name, version):
    """Take the package name and version and write a header for the
    freeze information."""

    info = "\\section " \
        + name + "_" + TextVersion(version) + "_history" \
        " Version " + FormatVersion(version) + "\n\n"
    info += "Freeze information:\n"
    info += "   - Freeze Date: " + time.ctime() + "\n"
    info += "   - Freeze User: " + pwd.getpwuid(os.getuid())[0] + "\n"
    info += "   - Freeze Host: " + socket.getfqdn(socket.gethostname())+"\n"
    info += "\n"
    
    ## If there is a name note it too.
    if (name == "captainRelease" and options.nameTag):
        nameTag = options.nameTag
        info += "CAPTAIN Software Version Codename :: "+nameTag+"\n"

    return info


############################################################
def EditHistoryMessage(fileName, name,version):
    """Call the editor to create a new history message

    This uses the EDITOR environment variable to find the right editor to
    create a new history message.  It then creates a template file and expects
    the user to fill it.  After the template file is created, it verifies that
    the history message is sufficient.
    """
    global options, config
    
    try:
        editor = os.environ["EDITOR"]
    except:
        editor = "emacs -nw"

    try:
        histFile = open(fileName,"w")
        histFile.write(GetFreezeInformation(name,version))
        histFile.write("""
HIST: *****************************************************************
HIST: Add a history message to this file.  Lines start with HIST will be
HIST: stripped from the final output.  There must be a blank line after the
HIST: freeze information since the first seven lines of the file will be
HIST: modified by capt-freeze.
HIST: 
HIST: This file must not be added to the repository.
""")
        histFile.close()
    except:
        sys.exit("Cannot write history template")

    os.system(editor + " " + fileName)

    try:
        histFile = open(fileName,"r")
        historyMessage = histFile.read()
        histFile.close()
    except:
        sys.exit("Could not read history template")

    return historyMessage
    

############################################################
def GetHistoryMessage(name,version):
    """Get the version history and return it as text.

    This checks for an existing version history file, but will call
    the user's editor if the file doesn't exist.  After reading the
    history file it is checked to make sure that it matches the right
    format, and the freeze information is updated.  It also strips the
    final comments that are not required.  The default history is
    saved in the GIT top level directory.
    """
    global options, config

    versionHistoryFile = options.versionHistory
    if versionHistoryFile == None:
        versionHistoryFile = "v%dr%dp%d_history.txt" % version
        versionHistoryFile = config.toplevel + "/" + versionHistoryFile
    if os.path.exists(versionHistoryFile):
        # If the version history exists, use that file.
        print "    History File:   ", os.path.relpath(versionHistoryFile)
        try:
            histFile = open(versionHistoryFile,'r')
            history = histFile.read()
            histFile.close()
        except IOError, hist:
            sys.exit("Cannot open " + versionHistoryFile
                     + " for reading, exiting..")
    else:
        history = EditHistoryMessage(versionHistoryFile,name,version)

    ####################################################################
    # Update the history and freeze information.

    # Strip the HIST comments from the end of the file.
    histList = [line for line in history.splitlines()[7:]
                if not line.startswith("HIST")]

    # Verify that the history file has been updated with a real message.
    historyOk = 0
    for line in histList:
        if len(line.split()) > 4: historyOk += 1

    history = "\n".join(GetFreezeInformation(name,version).splitlines()
                        +histList)
    
    if options.checkHistory:
        if historyOk < 3:
            sys.exit("History message is not long enough.  Edit " \
                     + versionHistoryFile)
    else:
        print "WARNING: Check of history message has been disabled."

    return (history, versionHistoryFile)


############################################################
def GetHistoryFile(name):
    """Get the name of the history file

    This returns the name of the history file in the package doc directory.
    If the file doesn't exist, it will exit the script with a message
    telling the user how to create the approprate file.
    """
    global config

    histDir = config.toplevel

    if config.useCMT:
        if config.cmtPackage: histDir = config.toplevel+"/doc"
        else: histDir = config.toplevel+"/cmt"

    if not os.path.exists(histDir+"/"):
        print "WARNING: Creating a documentation directory"
        os.makedirs(histDir)

    histFile = histDir + "/" + name+"History.dox"

    # check if the history file exists, and create it if it does not.
    if not os.path.exists(histFile):
        print "WARNING: The history file is missing.   It will be created."
        try:
            h = open(histFile,"w")
            h.write("/*! \\page " + name + "History"
                    + " History for the " 
                    + name + " Package \n"
                    + "*/\n")
            h.close()
        except IOError:
            sys.exit("Unable to create the history file")
        print "    Created", histFile
    return histFile


############################################################
def UpdateVersionHistory(name,version):
    """Update the version history file.

    This adds the content new version history file to the existing
    version history.  The existing history file is found by
    GetHistoryFile.  This will start an editor and prompt the user to
    write a history message if the version history was not provided.
    This returns the name of the file containing the history message
    that got appended to the main package history.  This file can be
    used as a commit message.
    """

    # Get the text of the history message, and the file containing the text.
    (historyText, historyFile) = GetHistoryMessage(name,version)        

    # Look for the version history file. If it cannot be found exit and
    # request a version be checked out or created.
    histFileName = GetHistoryFile(name)
    try:
        histFile = open(histFileName,'r')
        history = histFile.read()
        histFile.close()
    except:
        error = """

        This file is required to run capt-freeze. Please check this
        file out of the repository, or create the file and add it to
        the repository before running capt-freeze again."""
        sys.exit("EXITING: Cannot read " + histFileName + error)

    ########################################################
    # Make sure that the history is a correct Doxygen page.
    ########################################################
    if not options.dryRun:
        # Find the right place to insert the new history message.
        insertHere = re.match(r'^(/\*!.*)(\*/)$',history,re.DOTALL)
        if not insertHere:
            sys.exit("ERROR: History file is not formatted as a block comment.")

        buildHistory = insertHere.group(1)
        buildHistory += "\n"
        buildHistory += historyText
        buildHistory += "\n"
        buildHistory += insertHere.group(2)
            
        try:
            histFile = open(histFileName + ".tmp",'w')
            history = histFile.write(buildHistory)
            histFile.close()
        except:
            sys.exit("EXITING: Cannot write " + histFileName + ".tmp")
                
        os.rename(histFileName,histFileName+".old~")
        os.rename(histFileName+".tmp",histFileName)
    else:
        print "WARNING: doxygen history file not updated during a dry run"

    Command("git add "+histFileName)
    Command("""git commit -m "Update history file." """)

    return historyFile


#################################################################
def UpdateVersion(version):
    """Change the version for CMT.  This only does something in a package."""
    global config
    if not config.cmtPackage: return False
    
    fname = config.toplevel + "/cmt/version.cmt"
    Command("echo  " + FormatVersion(version) + " > " + fname)
    Command("git add " + fname)
    Command("""git commit -m "Update version.cmt." """)
    return True


#################################################################
def CheckRepositoryStatus():
    """Check that the package is up to date with the central repository"""

    statusOK = True

    if not options.skipRemoteCheck and len(git.GetRemotes()) < 1:
        print "ERROR: Repository has no remote origin. ",\
            "Override with --skip-remote-check"
        statusOK = False

    if not options.skipAheadCheck and git.BranchAhead() != 0:
        print "ERROR: Local branch is", git.BranchAhead(False), \
            "commits ahead of remote."
        print "    Override with --skip-ahead-check"
        statusOK = False
    
    if not options.skipModifiedCheck and git.BranchModified():
        print "ERROR: Local branch has modified files. ",\
            "Override with --skip-modified-check"
        statusOK = False

    if not options.skipUntrackedCheck and git.BranchUntracked():
        print "ERROR: Local branch has modified files. ", \
            "Override with --skip-untracked-check"
        statusOK = False
        
    if not statusOK: 
        sys.exit(textwrap.fill("The local repository is not synchronized with the remote.  Please make sure all of your changes are pushed to the remote repository and that you have merged all of the changes from the remote."))


#################################################################
# START THE REAL SCRIPT

# Check that the local repository is up to date.
CheckRepositoryStatus()

# Get the next version.
(nextVersion, previousVersion) = GetNextVersion()

# Save the current branch name
currentBranch = git.BranchName()

print "Freeze of", config.name

# Nicely format the top level path.  This truncates the length if it
# is to long by chopping off directories at the beginning and
# replacing them with "..."
cwd = ""
dirlist = os.path.realpath(config.toplevel).split("/")
dirlist.reverse()
for d in dirlist:
    if d == "": break
    if len(cwd)+len(d) > 50: break
    cwd = "/" + d + cwd
if len(cwd) < len(os.path.realpath(config.toplevel)): cwd = "..."+cwd
print "    Top level:      ", cwd

print "    Current Branch: ", currentBranch
print "    Release Branch: ", FormatBranch(nextVersion)
print "    New Version:    ", FormatVersion(nextVersion)

historyFile = UpdateVersionHistory(config.name, nextVersion)

# Make sure the freeze branch exists and change to it if necessary.
nextVersionBranch = FormatBranch(nextVersion)
if not git.BranchExists(nextVersionBranch):
    Command("git checkout -b " + nextVersionBranch)
else:
    Command("git checkout " + nextVersionBranch)

# Change the version number.  This also commands any changes added
# while preparing the package for the freeze (e.g. it commits the
# updated doxygen file)
UpdateVersion(nextVersion)

Command("git tag -a -F " + historyFile + " " + FormatVersion(nextVersion))

# Tweak the version.cmt file so that the head version always comes last.
headVersion = (nextVersion[0], nextVersion[1], 999)
UpdateVersion(headVersion)

# Return to the original branch.
Command("git checkout " + currentBranch)

if options.dryRun:
    print textwrap.fill("Use the --apply option to freeze the package or "
                   "run this command with the --help option for usage "
                   "information")
